{
	"info": {
		"_postman_id": "e322363b-4fda-4dc1-9e65-f80a50d766a0",
		"name": "Pay",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "13665391"
	},
	"item": [
		{
			"name": "400. /api/v1/payment/pay/:method_uuid. Картой СГ.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const { generateRandom10Digit } = require('./utils.js');",
							"const randomNumber = generateRandom10Digit();",
							"pm.globals.set('random10Digit', randomNumber);"													
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"// === КОНФИГУРАЦИЯ ===",							
							"const BASE_URL = pm.globals.get(\"AutomationPayStandRun\");",
							"const METHOD_UUID = pm.globals.get(\"PaymentMethodUuidSberGate\");",
							"const AUTH_TOKEN = pm.globals.get(\"PaymentTestBearerToken\");",
							"const ACCOUNT_ID = pm.globals.get(\"PayPaymentAccountId\");",
							"",
							"// Проверяем обязательные переменные окружения",
							"if (!BASE_URL) {",
							"    pm.test(\"Ошибка: переменная AutomationPayStandRun не задана\", () => {",
							"        pm.expect(false, \"Переменная AutomationPayStandRun не задана в окружении!\").to.be.true;",
							"    });",
							"    return; // Прекращаем выполнение скрипта",
							"}",
							"",
							"if (!METHOD_UUID) {",
							"    pm.test(\"Ошибка: переменная PaymentMethodUuidSberGate не задана\", () => {",
							"        pm.expect(false, \"Переменная PaymentMethodUuidSberGate не задана в окружении!\").to.be.true;",
							"    });",
							"    return; // Прекращаем выполнение скрипта",
							"}",
							"",
							"if (!AUTH_TOKEN) {",
							"    pm.test(\"Ошибка: переменная PaymentTestBearerToken не задана\", () => {",
							"        pm.expect(false, \"Переменная PaymentTestBearerToken не задана в окружении!\").to.be.true;",
							"    });",
							"    return; // Прекращаем выполнение скрипта",
							"}",
							"",
							"if (!ACCOUNT_ID) {",
							"    pm.test(\"Ошибка: переменная PayPaymentAccountId не задана\", () => {",
							"        pm.expect(false, \"Переменная PayPaymentAccountId не задана в окружении!\").to.be.true;",
							"    });",
							"    return; // Прекращаем выполнение скрипта",
							"}",
							"",
							"const ENDPOINT = `/api/v1/payment/pay/${METHOD_UUID}`;",
							"const DEFAULT_PAYLOAD = {",
							"    // Обязательные поля",
							"    amount: 2,",
							"    invoice_id: random10Digit,",
							"    mobile: false,",
							"    platform: \"WEB\",",
							"    ",
							"    // Идентификаторы",
							"    account_id: ACCOUNT_ID,",
							"    ",
							"    // Опциональные поля (можно удалять/изменять для тестов)",
							"    secure_pay: \"<string>\", // закомментировано по умолчанию",
							"    ",
							"    // Персональные данные",
							"    name: \"DeadCow\",",
							"    phone: \"79138166920\",",
							"    email: \"klepa_e@mail.ru\",",
							"    ",
							"    // Дополнительная информация",
							"    description: \"TestDeadCow\",",
							"    ",
							"    // Массив кастомных параметров",
							"    payload: [",
							"        {",
							"            key: \"testKey\",",
							"            value: \"testValue\"",
							"        }",
							"    ],",
							"    ",
							"    // Настройки перенаправлений и таймаутов",
							"    fields: {",
							"        successUrl: \"https://uat-pay.av.ru/success/123456\",",
							"        errorUrl: \"https://uat-pay.av.ru//error/123456\",",
							"        ttl: 3600",
							"    }",
							"};",
							"",
							"const { sendAndCheck, validateErrorResponse, validateFieldErrors, parseResponseJson } = require('./utils.js');",
							"",
							"// === ТЕСТЫ ===",
							"// === amount ===",
							"pm.test(\"1. amount: '1a!' + валидация структуры ответа\", async () => {",
              				"    const payload = { ...DEFAULT_PAYLOAD, amount: \"1a!\" };",
             				"    const testName = \"amount=1a!\";",
              				"",
              				"    try {",
              				"        const response = await sendAndCheck(payload, testName, [400]);",
              				"",
              				"        // Парсим JSON",
              				"        const responseBody = await parseResponseJson(response);",
              				"",
              				"        // Общие проверки структуры",
              				"        validateErrorResponse(",
              				"            responseBody,",
              				"            400,",
              				"            \"Не верные переданные данные в апи\",",
              				"            \"BAD_REQUEST\"",
              				"        );",
              				"",
              				"        // Специфичные проверки для поля `amount`",
              				"        pm.expect(responseBody.errors.amount).to.exist;",
              				"        validateFieldErrors(",
              				"            responseBody.errors.amount,",
              				"            \"Поле amount должно быть числом.\"",
              				"        );",
              				"",
              				"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
              				"",
              				"    } catch (error) {",
              				"        console.error(\"❌ Тест НЕ пройден:\", error.message);",
              				"        throw error;",
              				"    }",
              				"});",
							"",
							"pm.test(\"2. amount: {} + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, amount: {} };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"amount={}\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: amount =\", payload.amount);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.amount, \"Поле errors.amount отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.amount, \"errors.amount должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.amount.length, \"errors.amount не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.amount.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.amount[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.amount[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле amount обязательно для заполнения.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: amount =\", payload.amount);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"3. amount: [] + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, amount: [] };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"amount=[]\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: amount =\", payload.amount);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.amount, \"Поле errors.amount отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.amount, \"errors.amount должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.amount.length, \"errors.amount не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.amount.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.amount[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.amount[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле amount обязательно для заполнения.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: amount =\", payload.amount);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"4. amount: false + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, amount: false };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"amount=false\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: amount =\", payload.amount);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.amount, \"Поле errors.amount отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.amount, \"errors.amount должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.amount.length, \"errors.amount не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.amount.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.amount[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.amount[${index}] не должен быть пустой строкой`).to.be.above(0);            ",
							"        });",
							"",
							"        // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле amount должно быть числом.\",",
							"        \"Поле amount должно быть не меньше 0.01.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.amount.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.amount`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.amount);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: amount =\", payload.amount);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"5. amount: null + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, amount: null };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"amount=null\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: amount =\", payload.amount);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.amount, \"Поле errors.amount отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.amount, \"errors.amount должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.amount.length, \"errors.amount не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.amount.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.amount[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.amount[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле amount обязательно для заполнения.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: amount =\", payload.amount);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"// === invoice_id ===",
							"pm.test(\"6. invoice_id: 2 + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, invoice_id: 2 };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"invoice_id=2\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: invoice_id =\", payload.invoice_id);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.invoice_id, \"Поле errors.invoice_id отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.invoice_id, \"errors.invoice_id должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.invoice_id.length, \"errors.invoice_id не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.invoice_id.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.invoice_id[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.invoice_id[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле invoice id должно быть строкой.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: invoice_id =\", payload.invoice_id);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"7. invoice_id: {} + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, invoice_id: {} };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"invoice_id={}\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: invoice_id =\", payload.invoice_id);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.invoice_id, \"Поле errors.invoice_id отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.invoice_id, \"errors.invoice_id должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.invoice_id.length, \"errors.invoice_id не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.invoice_id.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.invoice_id[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.invoice_id[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле invoice id обязательно для заполнения.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: invoice_id =\", payload.invoice_id);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"8. invoice_id: [] + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, invoice_id: [] };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"invoice_id=[]\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: invoice_id =\", payload.invoice_id);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.invoice_id, \"Поле errors.invoice_id отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.invoice_id, \"errors.invoice_id должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.invoice_id.length, \"errors.invoice_id не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.invoice_id.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.invoice_id[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.invoice_id[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле invoice id обязательно для заполнения.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: invoice_id =\", payload.invoice_id);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"9. invoice_id: false + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, invoice_id: false };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"invoice_id=false\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: invoice_id =\", payload.invoice_id);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.invoice_id, \"Поле errors.invoice_id отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.invoice_id, \"errors.invoice_id должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.invoice_id.length, \"errors.invoice_id не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.invoice_id.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.invoice_id[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.invoice_id[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле invoice id должно быть строкой.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: invoice_id =\", payload.invoice_id);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"10. invoice_id: null + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, invoice_id: null };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"invoice_id=null\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: invoice_id =\", payload.invoice_id);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.invoice_id, \"Поле errors.invoice_id отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.invoice_id, \"errors.invoice_id должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.invoice_id.length, \"errors.invoice_id не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.invoice_id.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.invoice_id[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.invoice_id[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле invoice id обязательно для заполнения.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: invoice_id =\", payload.invoice_id);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"// === mobile ===",
							"pm.test(\"11. mobile: 2 + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, mobile: 2 };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"mobile=2\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: mobile =\", payload.mobile);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.mobile, \"Поле errors.mobile отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.mobile, \"errors.mobile должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.mobile.length, \"errors.mobile не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.mobile.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.mobile[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.mobile[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле Моб. номер должно иметь значение логического типа.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: mobile =\", payload.mobile);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"12. mobile: `1a!` + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, mobile: \"1a!\" };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"mobile=1a!\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: mobile =\", payload.mobile);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.mobile, \"Поле errors.mobile отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.mobile, \"errors.mobile должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.mobile.length, \"errors.mobile не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.mobile.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.mobile[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.mobile[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле Моб. номер должно иметь значение логического типа.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: mobile =\", payload.mobile);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"13. mobile: {} + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, mobile: {} };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"mobile={}\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: mobile =\", payload.mobile);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.mobile, \"Поле errors.mobile отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.mobile, \"errors.mobile должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.mobile.length, \"errors.mobile не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.mobile.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.mobile[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.mobile[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле Моб. номер обязательно для заполнения.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: mobile =\", payload.mobile);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"14. mobile: [] + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, mobile: [] };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"mobile=[]\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: mobile =\", payload.mobile);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.mobile, \"Поле errors.mobile отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.mobile, \"errors.mobile должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.mobile.length, \"errors.mobile не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.mobile.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.mobile[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.mobile[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле Моб. номер обязательно для заполнения.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: mobile =\", payload.mobile);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"15. mobile: null + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, mobile: null };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"mobile=null\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: mobile =\", payload.mobile);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.mobile, \"Поле errors.mobile отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.mobile, \"errors.mobile должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.mobile.length, \"errors.mobile не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.mobile.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.mobile[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.mobile[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле Моб. номер обязательно для заполнения.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: mobile =\", payload.mobile);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"// === platform ===",
							"pm.test(\"16. platform: 2 + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, platform: 2 };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"platform=2\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: platform =\", payload.platform);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.platform, \"Поле errors.platform отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.platform, \"errors.platform должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.platform.length, \"errors.platform не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.platform.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.platform[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.platform[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле platform должно быть строкой.\",",
							"        \"Выбранное значение для platform ошибочно.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.platform.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.platform`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.platform);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: platform =\", payload.platform);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"17. platform: {} + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, platform: {} };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"platform={}\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: platform =\", payload.platform);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.platform, \"Поле errors.platform отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.platform, \"errors.platform должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.platform.length, \"errors.platform не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.platform.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.platform[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.platform[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле platform обязательно для заполнения.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.platform.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.platform`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.platform);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: platform =\", payload.platform);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"18. platform: [] + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, platform: [] };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"platform=[]\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: platform =\", payload.platform);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.platform, \"Поле errors.platform отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.platform, \"errors.platform должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.platform.length, \"errors.platform не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.platform.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.platform[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.platform[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле platform обязательно для заполнения.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.platform.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.platform`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.platform);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: platform =\", payload.platform);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"19. platform: false + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, platform: false };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"platform=false\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: platform =\", payload.platform);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.platform, \"Поле errors.platform отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.platform, \"errors.platform должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.platform.length, \"errors.platform не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.platform.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.platform[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.platform[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле platform должно быть строкой.\",",
							"        \"Выбранное значение для platform ошибочно.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.platform.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.platform`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.platform);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: platform =\", payload.platform);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"20. platform: null + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, platform: null };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"platform=null\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: platform =\", payload.platform);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.platform, \"Поле errors.platform отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.platform, \"errors.platform должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.platform.length, \"errors.platform не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.platform.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.platform[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.platform[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле platform обязательно для заполнения.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.platform.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.platform`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.platform);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: platform =\", payload.platform);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"// === account_id ===",
							"pm.test(\"21. account_id: 2 + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, account_id: 2 };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"account_id=2\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: account_id =\", payload.account_id);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.account_id, \"Поле errors.account_id отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.account_id, \"errors.account_id должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.account_id.length, \"errors.account_id не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.account_id.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.account_id[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.account_id[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле account id должно быть строкой.\",",
							"        \"Поле account id имеет ошибочный формат.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.account_id.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.account_id`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.account_id);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: account_id =\", payload.account_id);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"22. account_id: {} + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, account_id: {} };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"account_id={}\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: account_id =\", payload.account_id);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.account_id, \"Поле errors.account_id отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.account_id, \"errors.account_id должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.account_id.length, \"errors.account_id не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.account_id.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.account_id[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.account_id[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле account id должно быть строкой.\",",
							"        \"Поле account id имеет ошибочный формат.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.account_id.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.account_id`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.account_id);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: account_id =\", payload.account_id);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"23. account_id: [] + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, account_id: [] };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"account_id=[]\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: account_id =\", payload.account_id);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.account_id, \"Поле errors.account_id отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.account_id, \"errors.account_id должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.account_id.length, \"errors.account_id не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.account_id.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.account_id[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.account_id[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле account id должно быть строкой.\",",
							"        \"Поле account id имеет ошибочный формат.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.account_id.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.account_id`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.account_id);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: account_id =\", payload.account_id);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"24. account_id: false + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, account_id: false };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"account_id=false\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: account_id =\", payload.account_id);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.account_id, \"Поле errors.account_id отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.account_id, \"errors.account_id должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.account_id.length, \"errors.account_id не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.account_id.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.account_id[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.account_id[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле account id должно быть строкой.\",",
							"        \"Поле account id имеет ошибочный формат.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.account_id.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.account_id`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.account_id);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: account_id =\", payload.account_id);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"25. account_id: null + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, account_id: null };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"account_id=null\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: account_id =\", payload.account_id);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.account_id, \"Поле errors.account_id отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.account_id, \"errors.account_id должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.account_id.length, \"errors.account_id не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.account_id.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.account_id[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.account_id[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле account id должно быть строкой.\",",
							"        \"Поле account id имеет ошибочный формат.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.account_id.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.account_id`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.account_id);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: account_id =\", payload.account_id);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"// === name ===",
							"pm.test(\"26. name: 2 + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, name: 2 };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"name=2\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: name =\", payload.name);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.name, \"Поле errors.name отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.name, \"errors.name должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.name.length, \"errors.name не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.name.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.name[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.name[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле Имя должно быть строкой.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.name.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.name`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.name);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: name =\", payload.name);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"27. name: {} + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, name: {} };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"name={}\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: name =\", payload.name);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.name, \"Поле errors.name отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.name, \"errors.name должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.name.length, \"errors.name не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.name.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.name[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.name[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле Имя должно быть строкой.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.name.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.name`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.name);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: name =\", payload.name);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"28. name: [] + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, name: [] };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"name=[]\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: name =\", payload.name);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.name, \"Поле errors.name отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.name, \"errors.name должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.name.length, \"errors.name не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.name.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.name[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.name[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле Имя должно быть строкой.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.name.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.name`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.name);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: name =\", payload.name);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"29. name: false + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, name: false };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"name=false\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: name =\", payload.name);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.name, \"Поле errors.name отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.name, \"errors.name должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.name.length, \"errors.name не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.name.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.name[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.name[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле Имя должно быть строкой.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.name.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.name`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.name);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: name =\", payload.name);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"pm.test(\"30. name: null + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, name: false };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"name=null\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: name =\", payload.name);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.name, \"Поле errors.name отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.name, \"errors.name должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.name.length, \"errors.name не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.name.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.name[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.name[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле Имя должно быть строкой.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.name.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.name`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.name);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: name =\", payload.name);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							"",
							"// === payload ===",
							"pm.test(\"31. payload: 2 + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, payload: 2 };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"payload=2\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: payload =\", payload.payload);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.payload, \"Поле errors.name отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.payload, \"errors.name должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.payload.length, \"errors.name не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.payload.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.payload[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.payload[${index}] не должен быть пустой строкой`).to.be.above(0);        ",
							"        });",
							"",
							"            // Список ожидаемых сообщений (все должны присутствовать)",
							"    const expectedMessages = [",
							"        \"Поле payload должно быть массивом.\"",
							"    ];",
							"",
							"    // Проверяем, что каждое ожидаемое сообщение присутствует в ответе",
							"    expectedMessages.forEach(expectedMsg => {",
							"        const isFound = responseBody.errors.payload.includes(expectedMsg);",
							"        ",
							"        pm.expect(",
							"            isFound, ",
							"            `Ожидаемое сообщение \"${expectedMsg}\" не найдено в errors.payload`",
							"        ).to.be.true;",
							"    });",
							"",
							"    // Дополнительно: выводим все найденные сообщения",
							"    console.log(\"Все сообщения валидации:\", responseBody.errors.payload);",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: payload =\", payload.payload);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});"
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "PaymentTestBearerToken",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/json",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"amount\": 2,\r\n  \"invoice_id\": \"{{random10Digit}}\",\r\n  \"mobile\": false,\r\n  \"platform\": \"WEB\",\r\n  \"account_id\": \"{{PayPaymentAccountId}}\",  \r\n//   \"secure_pay\": \"<string>\",\r\n  \"name\": \"DeadCow\",\r\n  \"payload\": [    \r\n    {\r\n      \"key\": \"testKey\",\r\n      \"value\": \"testValue\"\r\n    }\r\n  ],\r\n  \"phone\": \"79138166920\",\r\n  \"email\": \"klepa_e@mail.ru\",\r\n  \"description\": \"TestDeadCow\",\r\n  \"fields\": {\r\n    \"successUrl\": \"https://uat-pay.av.ru/success/123456\",\r\n    \"errorUrl\": \"https://uat-pay.av.ru//error/123456\",\r\n    \"ttl\": 3600\r\n  }  \r\n}\r\n",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "AutomationPayStandRun/api/v1/payment/pay/:method_uuid",
					"host": [
						"AutomationPayStandRun"
					],
					"path": [
						"api",
						"v1",
						"payment",
						"pay",
						":method_uuid"
					],
					"variable": [
						{
							"key": "method_uuid",
							"value": "PaymentMethodUuidSberGate"
						}
					]
				}
			},
			"response": []
		}
	]
}