{
	"item": [
		{
			"name": "400. /api/v1/payment/pay/:method_uuid. Картой СГ.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const { generateRandom10Digit } = require('./functions.js');",
							"const randomNumber = generateRandom10Digit();",
							"pm.globals.set('random10Digit', randomNumber);"						
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"// === КОНФИГУРАЦИЯ ===",
							"const BASE_URL = pm.globals.get(\"AutomationPayStandRun\");",
							"const METHOD_UUID = pm.globals.get(\"PaymentMethodUuidSberGate\");",
							"const AUTH_TOKEN = pm.globals.get(\"PaymentTestBearerToken\");",
							"const ACCOUNT_ID = pm.globals.get(\"PayPaymentAccountId\");",							
							"",
							"// Проверяем обязательные переменные окружения",
							"if (!BASE_URL) {",
							"    pm.test(\"Ошибка: переменная AutomationPayStandRun не задана\", () => {",
							"        pm.expect(false, \"Переменная AutomationPayStandRun не задана в окружении!\").to.be.true;",
							"    });",
							"    return; // Прекращаем выполнение скрипта",
							"}",
							"",
							"if (!METHOD_UUID) {",
							"    pm.test(\"Ошибка: переменная PaymentMethodUuidSberGate не задана\", () => {",
							"        pm.expect(false, \"Переменная PaymentMethodUuidSberGate не задана в окружении!\").to.be.true;",
							"    });",
							"    return; // Прекращаем выполнение скрипта",
							"}",
							"",
							"if (!AUTH_TOKEN) {",
							"    pm.test(\"Ошибка: переменная PaymentTestBearerToken не задана\", () => {",
							"        pm.expect(false, \"Переменная PaymentTestBearerToken не задана в окружении!\").to.be.true;",
							"    });",
							"    return; // Прекращаем выполнение скрипта",
							"}",
							"",
							"if (!ACCOUNT_ID) {",
							"    pm.test(\"Ошибка: переменная PayPaymentAccountId не задана\", () => {",
							"        pm.expect(false, \"Переменная PayPaymentAccountId не задана в окружении!\").to.be.true;",
							"    });",
							"    return; // Прекращаем выполнение скрипта",
							"}",
							"",
							"if (!RANDOM) {",
							"    pm.test(\"Ошибка: переменная random10Digit не задана\", () => {",
							"        pm.expect(false, \"Переменная random10Digit не задана в окружении!\").to.be.true;",
							"    });",
							"    return; // Прекращаем выполнение скрипта",
							"}",
							"",
							"const ENDPOINT = `/api/v1/payment/pay/${METHOD_UUID}`;",
							"const DEFAULT_PAYLOAD = {",
							"    // Обязательные поля",
							"    amount: 2,",
							"    invoice_id: RANDOM,",
							"    mobile: false,",
							"    platform: \"WEB\",",
							"    ",
							"    // Идентификаторы",
							"    account_id: ACCOUNT_ID,",
							"    ",
							"    // Опциональные поля (можно удалять/изменять для тестов)",
							"    secure_pay: \"<string>\", // закомментировано по умолчанию",
							"    ",
							"    // Персональные данные",
							"    name: \"DeadCow\",",
							"    phone: \"79138166920\",",
							"    email: \"klepa_e@mail.ru\",",
							"    ",
							"    // Дополнительная информация",
							"    description: \"TestDeadCow\",",
							"    ",
							"    // Массив кастомных параметров",
							"    payload: [",
							"        {",
							"            key: \"testKey\",",
							"            value: \"testValue\"",
							"        }",
							"    ],",
							"    ",
							"    // Настройки перенаправлений и таймаутов",
							"    fields: {",
							"        successUrl: \"https://uat-pay.av.ru/success/123456\",",
							"        errorUrl: \"https://uat-pay.av.ru//error/123456\",",
							"        ttl: 3600",
							"    }",
							"};",
							"",
							"// === ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ===",
							"/**",
							" * Отправляет POST-запрос и проверяет статус",
							" * @param {Object} payload - тело запроса",
							" * @param {String} testName - название теста для лога",
							" * @param {Array} expectedStatuses - ожидаемые коды ответа (по умолчанию [400])",
							" * @returns {Promise} - промис для асинхронного ожидания",
							" */",
							"async function sendAndCheck(payload, testName, expectedStatuses = [400]) {",
							"    try {",
							"        //console.log(\"→ ОТПРАВЛЯЕМ ТЕЛО:\", JSON.stringify(payload, null, 2)); <- Если надо посмотреть тело запроса",
							"        ",
							"        const response = await pm.sendRequest({",
							"            url: BASE_URL + ENDPOINT,",
							"            method: \"POST\",",
							"            header: {",
							"                \"Content-Type\": \"application/json\",",
							"                \"Accept\": \"application/json\",",
							"                \"Authorization\": `Bearer ${AUTH_TOKEN}`",
							"            },",
							"            body: JSON.stringify(payload)",
							"        });",
							"",
							"        pm.expect(response.code).to.be.oneOf(expectedStatuses);",
							"        console.log(`✓ ${testName} → код: ${response.code}`);",
							"",
							"        // Вывод тела ответа при ошибке",
							"        if (!expectedStatuses.includes(response.code) && response.json) {",
							"            console.log(\"→ Ответ сервера:\", response.json());",
							"        }",
							"",
							"        return response;",
							"    } catch (error) {",
							"        console.error(`✗ Ошибка в тесте \"${testName}\":`, error.message);",
							"        throw error;",
							"    }",
							"}",
							"",
							"// === ТЕСТЫ ===",
							"// === amount ===",
							"pm.test(\"1. amount: '1a!' + валидация структуры ответа\", async () => {",
							"    const payload = { ...DEFAULT_PAYLOAD, amount: \"1a!\" };",
							"",
							"    try {",
							"        // 1. Выполняем запрос и сохраняем ответ",
							"        const response = await sendAndCheck(payload, \"amount=1a!\");",
							"",
							"        // 2. Проверяем статус кода (используем ответ из sendAndCheck)",
							"        console.log(\"→ Статус ответа:\", response.code);",
							"        console.log(\"→ Переданные данные: amount =\", payload.amount);",
							"",
							"        if (response.code !== 400) {",
							"            throw new Error(`Неожиданный статус кода: ${response.code}. Ожидалось 400`);",
							"        }",
							"",
							"        // 3. Получаем и парсим JSON из ответа sendAndCheck",
							"        let responseBody;",
							"        try {",
							"            responseBody = response.json(); // ← используем response, а не pm.response",
							"            console.log(\"✅ JSON успешно декодирован\");",
							"        } catch (jsonError) {",
							"            console.error(\"❌ Ошибка парсинга JSON:\", jsonError.message);",
							"            console.error(\"→ Сырой ответ:\", response.text()); // ← response.text()",
							"            throw new Error(\"Не удалось декодировать JSON: \" + jsonError.message);",
							"        }",
							"",
							"        // 4. Выводим полный ответ для визуального контроля",
							"        //console.log(\"→ Полученный JSON:\", JSON.stringify(responseBody, null, 2));",
							"",
							"",
							"        // 5. Валидируем наличие error_code",
							"        if (!responseBody.error_code) {",
							"            console.error(\"❌ Поле error_code отсутствует в ответе\");",
							"            console.error(\"→ Доступные поля:\", Object.keys(responseBody));",
							"            throw new Error(\"Поле error_code не найдено в ответе\");",
							"        }",
							"",
							"        // 6. Основные проверки с уточнёнными значениями",
							"        pm.expect(responseBody.error_code, \"Поле error_code отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_code, \"error_code должен быть числом\").to.be.a('number');",
							"        pm.expect(responseBody.error_code).to.equal(400); // ← Проверяем, что error_code === 400",
							"",
							"        pm.expect(responseBody.error_message, \"Поле error_message отсутствует\").to.exist;",
							"        pm.expect(responseBody.error_message, \"error_message должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.error_message.length, \"error_message не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.error_message).to.equal(\"Не верные переданные данные в апи\"); // ← НОВОЕ: проверка текста",
							"",
							"",
							"        pm.expect(responseBody.type_error, \"Поле type_error отсутствует\").to.exist;",
							"        pm.expect(responseBody.type_error, \"type_error должен быть строкой\").to.be.a('string');",
							"        pm.expect(responseBody.type_error.length, \"type_error не должен быть пустым\").to.be.above(0);",
							"        pm.expect(responseBody.type_error).to.equal(\"BAD_REQUEST\"); // ← НОВОЕ: проверка значения",
							"",
							"",
							"        pm.expect(responseBody.errors, \"Поле errors отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors, \"errors должен быть объектом\").to.be.an('object');",
							"",
							"",
							"        pm.expect(responseBody.errors.amount, \"Поле errors.amount отсутствует\").to.exist;",
							"        pm.expect(responseBody.errors.amount, \"errors.amount должен быть массивом\").to.be.an('array');",
							"        pm.expect(responseBody.errors.amount.length, \"errors.amount не должен быть пустым массивом\").to.be.above(0);",
							"",
							"        responseBody.errors.amount.forEach((msg, index) => {",
							"            pm.expect(msg, `Элемент errors.amount[${index}] должен быть строкой`).to.be.a('string');",
							"            pm.expect(msg.length, `Элемент errors.amount[${index}] не должен быть пустой строкой`).to.be.above(0);",
							"            pm.expect(msg).to.equal(\"Поле amount должно быть числом.\"); // ← НОВОЕ: проверка текста в массиве",
							"        });",
							"",
							"        console.log(\"✅ Все проверки структуры ответа успешно пройдены\");",
							"",
							"    } catch (error) {",
							"        console.error(\"❌ Тест НЕ пройден: ошибка валидации\");",
							"        console.error(\"→ Причина:\", error.message);",
							"        console.error(\"→ Переданные данные: amount =\", payload.amount);",
							"",
							"",
							"        // Выводим ответ сервера, если доступен",
							"        if (error.response) {",
							"            console.error(\"→ Статус кода:\", error.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", error.response.text());",
							"        } else if (pm.response) {",
							"            console.error(\"→ Статус кода:\", pm.response.code);",
							"            console.error(\"→ Тело ответа (сырое):\", pm.response.text());",
							"        }",
							"",
							"        throw error;",
							"    }",
							"});",
							""
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{PaymentTestBearerToken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "Accept",
						"value": "application/json",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"amount\": 2,\r\n  \"invoice_id\": \"{{random10Digit}}\",\r\n  \"mobile\": false,\r\n  \"platform\": \"WEB\",\r\n  \"account_id\": \"{{PayPaymentAccountId}}\",  \r\n//   \"secure_pay\": \"<string>\",\r\n  \"name\": \"DeadCow\",\r\n  \"payload\": [    \r\n    {\r\n      \"key\": \"testKey\",\r\n      \"value\": \"testValue\"\r\n    }\r\n  ],\r\n  \"phone\": \"79138166920\",\r\n  \"email\": \"klepa_e@mail.ru\",\r\n  \"description\": \"TestDeadCow\",\r\n  \"fields\": {\r\n    \"successUrl\": \"https://uat-pay.av.ru/success/123456\",\r\n    \"errorUrl\": \"https://uat-pay.av.ru//error/123456\",\r\n    \"ttl\": 3600\r\n  }  \r\n}\r\n",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{AutomationPayStandRun}}/api/v1/payment/pay/:method_uuid",
					"host": [
						"{{AutomationPayStandRun}}"
					],
					"path": [
						"api",
						"v1",
						"payment",
						"pay",
						":method_uuid"
					],
					"variable": [
						{
							"key": "method_uuid",
							"value": "{{PaymentMethodUuidSberGate}}"
						}
					]
				}
			},
			"response": []
		}
	]
}